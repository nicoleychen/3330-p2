<html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
      .county {
        fill: lightgrey;
      }
      .outline {
        fill: none;
        stroke: black;
        stroke-width: 1px;
      }
      .graticule {
        fill: none;
        stroke: grey;
        stroke-width: 1px;
      }
      .state-outline {
        fill: none;
        stroke: darkgray;
        stroke-width: 3px;
      }
    </style>
  </head>
  <body>
    <svg id="map" height="770" width="990" style="margin: 20px"></svg>
    <svg id="pie"></svg>
    <script>
      const svg = d3.select("#map");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;
      const map = svg
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      const requestData = async function () {
        const internet = await d3.csv("kaggle_internet.csv");
        const nyc = await d3.json("borough.topo.json");
        // console.log(internet);
        // console.log(nyc);
        // console.log(nyc.objects.collection);
        var counties = topojson.feature(nyc, nyc.objects.collection); // List of state outlines to fill
        var countiesMesh = topojson.mesh(nyc, nyc.objects.collection); // 'Mesh' of all outlines put together for a stroke
        var projection = d3
          .geoMercator()
          .fitSize([mapWidth, mapHeight], counties);
        var path = d3.geoPath().projection(projection);

        let graticule = d3.geoGraticule10();
        // console.log(graticule);
        map
          .append("path")
          .attr("class", "graticule")
          .attr("d", path(graticule));

        // 2c. Draw states and outlines (see CSS at the top)
        let countyPaths = map
          .selectAll("path.county")
          .data(counties.features)
          .join("path")
          .attr("class", "county")
          .attr("note", (d) => d.id) // debugging
          .attr("d", path)
          .on("mouseover", mouseEntersState)
          .on("mouseout", mouseLeavesState)
          .on("click", updatePie);

        map
          .append("path")
          .datum(countiesMesh)
          .attr("class", "outline")
          .attr("d", path);

        let ny_count = 0;
        internet.forEach((d) => {
          if (d["state"] == "NY") {
            // console.log(d);
            ny_count += 1;
          }
        });
        let boroughs = [
          "Bronx County",
          "Kings County",
          "New York County",
          "Queens County",
          "Richmond County",
        ];
        let borough_to_county = {
          "Bronx County": "Bronx",
          "Kings County": "Brooklyn",
          "New York County": "Manhattan",
          "Queens County": "Queens",
          "Richmond County": "Staten Island",
        };
        let county_to_borough = {
          Bronx: "Bronx County",
          Brooklyn: "Kings County",
          Manhattan: "New York County",
          Queens: "Queens County",
          "Staten Island": "Richmond County",
        };
        let nyc_internet = internet.filter((d) =>
          boroughs.includes(d["county"])
        );
        // console.log(nyc_internet);
        // console.log(ny_count);

        var boroughDict = {}; // stateID ===> stateData
        nyc_internet.forEach((d) => {
          let borough = borough_to_county[d.county];
          boroughDict[borough] = d;
        });
        console.log(boroughDict);

        const minMax = d3.extent(nyc_internet, (d) => d.percent_no_internet);
        // const colorScale = d3
        //   .scaleLinear()
        //   .domain(d3.map(nyc_internet, d => d.percent_no_internet))
        //   .range(['white', 'blue']);
        const colorScale = d3
          .scaleSequential(d3.interpolateBuPu)
          .domain(minMax);

        map
          .selectAll(".county")
          .style("fill", (d) =>
            colorScale(boroughDict[d.properties.BoroName].percent_no_internet)
          );

        let tooltipWidth = 120;
        let tooltipHeight = 40;
        var format = d3.format(".2f");
        let tooltip = map
          .append("g")
          .attr("class", "tooltip")
          .attr("visibility", "hidden");
        tooltip
          .append("rect")
          .attr("fill", "lightgray")
          .attr("opacity", 0.9)
          .attr("x", -tooltipWidth / 2.0)
          .attr("y", 0)
          .attr("width", tooltipWidth)
          .attr("height", tooltipHeight);
        let percentage_text = tooltip
          .append("text")
          .attr("fill", "black")
          .attr("text-anchor", "middle")
          .attr("alignment-baseline", "hanging")
          .attr("x", 0)
          .attr("y", 2);

        function mouseEntersState() {
          // Make tooltip visible
          tooltip.style("visibility", "visible");

          // Find the state SVG element and add stroke
          let borough = d3.select(this);
          borough.attr("stroke", "black").attr("stroke-width", 3);
          let name = borough.datum().properties.BoroName;
          let countyData = boroughDict[name];
          percentage_text.text(format(countyData.percent_no_internet) + "%");

          let bounds = path.bounds(borough.datum());
          let xPos = (bounds[0][0] + bounds[1][0]) / 2.0;
          let yPos = bounds[0][1] + 50;
          tooltip.attr("transform", `translate(${xPos},${yPos})`);
        }
        function mouseLeavesState() {
          // Hide when you leave a state
          tooltip.style("visibility", "hidden");

          let borough = d3.select(this);
          borough.attr("stroke", "none").attr("stroke-width", 0);
        }

        // let nyc_school = nyc.filter((d) =>
        //   boroughs.includes(d["county"])
        // );

        let pieHeight = 600;
        let pieWidth = 600;
        let pieMargin = 40;

        let pie = d3
          .select("#pie")
          .attr("width", pieWidth)
          .attr("height", pieHeight + 50)
          .append("g")
          .attr("transform", `translate(${pieWidth / 2}, ${pieHeight / 2})`);

        pie
          .append("text")
          .text("Education Levels by County")
          .attr("text-anchor", "middle")
          .attr("font-size", 20)
          .attr("x", 0)
          .attr("y", 300);
        let pieDomain = [
          "P_below_middle_school",
          "P_some_high_school",
          "P_high_school_equivalent",
          "P_some_college",
          "P_bachelor_and_above",
          "P_other",
        ];

        let nyc_school = {};
        boroughs.forEach((borough) => {
          // console.log(borough);
          // console.log(boroughDict[borough_to_county[borough]]);
          nyc_school[borough] = {
            P_below_middle_school:
              boroughDict[borough_to_county[borough]].P_below_middle_school,
            P_some_high_school:
              boroughDict[borough_to_county[borough]].P_some_high_school,
            P_high_school_equivalent:
              boroughDict[borough_to_county[borough]].P_high_school_equivalent,
            P_some_collegel:
              boroughDict[borough_to_county[borough]].P_some_college,
            P_bachelor_and_above:
              boroughDict[borough_to_county[borough]].P_bachelor_and_above,
            P_other: (
              boroughDict[borough_to_county[borough]].P_total -
              boroughDict[borough_to_county[borough]].P_below_middle_school -
              boroughDict[borough_to_county[borough]].P_some_high_school -
              boroughDict[borough_to_county[borough]].P_high_school_equivalent -
              boroughDict[borough_to_county[borough]].P_some_college -
              boroughDict[borough_to_county[borough]].P_bachelor_and_above
            ).toString(),
          };
        });
        console.log(nyc_school);
        // .append("g")

        let pieColorScale = d3
          .scaleOrdinal()
          .domain(pieDomain)
          .range(d3.schemeSet3);

        function updatePie() {
          let selected = d3.select(this);

          console.log(selected);
          let name = county_to_borough[selected.datum().properties.BoroName];
          console.log(name);
          let d3pie = d3.pie().value((d) => {
            return d[1];
          });

          let dataReady = d3pie(Object.entries(nyc_school[name]));
          const u = pie.selectAll("path").data(dataReady);
          u.join("path")
            .transition()
            .duration(1000)
            .attr(
              "d",
              d3
                .arc()
                .innerRadius(0)
                .outerRadius(Math.min(pieHeight, pieWidth) / 2 - pieMargin)
            )
            .attr("fill", function (d) {
              return pieColorScale(d.data[0]);
            })
            .attr("stroke", "white")
            .style("stroke-width", "2px")
            .style("opacity", 1);
        }

        // let sum = boroughDict[Bronx].P_total;

        // let P_remaining =
        //   sum -
        //   boroughDict[Bronx].P_below_middle_school -
        //   boroughDict[Bronx].P_some_high_school -
        //   boroughDict[Bronx].P_high_school_equivalent -
        //   boroughDict[Bronx].P_some_college -
        //   boroughDict[Bronx].P_bachelor_and_above;
        updatePie();
      };

      requestData();
    </script>
  </body>
</html>
