<html>
  <head>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <style>
      .county {
      fill: lightgrey;
      }
      .outline {
      fill: none;
      stroke: black;
      stroke-width: 1px;
      }
      .graticule {
          fill: none;
          stroke: grey;
          stroke-width: 1px;
      }
      .state-outline {
        fill: none;
        stroke: darkgray;
        stroke-width: 3px;
      } 
    </style>
  </head>
  <body>
    <svg id="map" height="770" width="990" style="margin:20px"></svg>

    <script>
      const svg = d3.select("#map");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left:20};
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;
      const map = svg.append("g")
                      .attr("transform","translate("+margin.left+","+margin.top+")");

      const requestData = async function() {
        const internet = await d3.csv("kaggle_internet.csv");
        const nyc = await d3.json("borough.topo.json");
        console.log(internet);
        console.log(nyc);
        console.log(nyc.objects.collection);
        var counties = topojson.feature(nyc, nyc.objects.collection);     // List of state outlines to fill
        var countiesMesh = topojson.mesh(nyc, nyc.objects.collection);    // 'Mesh' of all outlines put together for a stroke
        var projection = d3.geoMercator().fitSize([mapWidth, mapHeight], counties);
        var path = d3.geoPath().projection(projection);

        let graticule = d3.geoGraticule10();
        // console.log(graticule);
        map.append("path").attr("class","graticule").attr("d", path(graticule));
        
        
        // 2c. Draw states and outlines (see CSS at the top)
        let countyPaths = map.selectAll("path.county").data(counties.features)
                        .join("path")
                        .attr("class", "county")
                        .attr("note", d => d.id)  // debugging
                        .attr("d", path)
                        .on('mouseover',  mouseEntersState )
                        .on('mouseout',  mouseLeavesState );
      
        map.append("path").datum(countiesMesh)
          .attr("class","outline")
          .attr("d", path);


        let ny_count = 0;
        internet.forEach((d) => {
          if (d["state"]=="NY"){
            // console.log(d);
            ny_count+=1;
          }
        });
        let boroughs = ["Bronx County", "Kings County", "New York County", "Queens County", "Richmond County"];
        let borough_to_county = {
          "Bronx County":"Bronx",
          "Kings County":"Brooklyn",
          "New York County":"Manhattan",
          "Queens County":"Queens",
          "Richmond County":"Staten Island"
        }
        let nyc_internet = internet.filter(d=>(boroughs.includes(d["county"])));
        console.log(nyc_internet);
        console.log(ny_count);

        var boroughDict = {}   // stateID ===> stateData
        nyc_internet.forEach( d => {
          let borough = borough_to_county[d.county];
          boroughDict[borough] = d;
        });
        console.log(boroughDict);

        const minMax = d3.extent( nyc_internet, d => d.percent_no_internet );
        // const colorScale = d3
        //   .scaleLinear()
        //   .domain(d3.map(nyc_internet, d => d.percent_no_internet))
        //   .range(['white', 'blue']);
        const colorScale = d3.scaleSequential(d3.interpolateBuPu).domain(minMax);

        map.selectAll(".county")
        .style("fill", d => colorScale( boroughDict[d.properties.BoroName].percent_no_internet ) );

        let tooltipWidth = 120;
        let tooltipHeight = 40;
        var format = d3.format(".2f")
        let tooltip = map.append("g")
          .attr("class","tooltip")
          .attr("visibility","hidden");
        tooltip.append("rect")
          .attr("fill", "lightgray")
          .attr("opacity", 0.9)
          .attr("x", -tooltipWidth / 2.0)
          .attr("y", 0)
          .attr("width",tooltipWidth)
          .attr("height",tooltipHeight);
        let percentage_text = tooltip.append("text")
          .attr("fill", "black")
          .attr("text-anchor","middle")
          .attr("alignment-baseline","hanging")
          .attr("x", 0)
          .attr("y", 2);

        function mouseEntersState() {
          // Make tooltip visible
          tooltip.style("visibility","visible")
      
          // Find the state SVG element and add stroke
          let borough = d3.select(this);
          borough.attr("stroke","black")
            .attr("stroke-width", 3);
          let name = borough.datum().properties.BoroName;
          let countyData = boroughDict[name]
          percentage_text.text(format(countyData.percent_no_internet)+"%");

          let bounds = path.bounds( borough.datum() );   
          let xPos = (bounds[0][0]+bounds[1][0])/2.0;
          let yPos = bounds[0][1]+ 50;
          tooltip.attr("transform",`translate(${xPos},${yPos})`);
          
        }
        function mouseLeavesState() {
  
          // Hide when you leave a state
          tooltip.style("visibility","hidden");

          let borough = d3.select(this);
          borough.attr("stroke","none")
            .attr("stroke-width", 0);
        }
        
      }

      requestData();

    </script>
  </body>
    
</html>
